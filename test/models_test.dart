import 'dart:convert';
import 'dart:developer' as developer;

import 'package:flutter_notes/data/models.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('Note', () {
    Note note;
    Map<String, dynamic> mapData;
    String jsonData;

    setUpAll(() {
      note = Note(
        title: 'Title of test note',
        content: 'Content of test note',
      );

      mapData = {
        "id": "${note.id}",
        "title": "${note.title}",
        "content": "${note.content}",
      };

      jsonData = '{"id":"${note.id}","title":"${note.title}","content":"${note.content}"}';
    });

    test('to map', () {
      expect(note.toMap(), equals(mapData));
    });

    test('from map', () {
      var actual = Note.fromMap(mapData);
      expect(actual.toJson(), equals(note.toJson()));
    });

    test('to JSON', () {
      expect(jsonEncode(note), equals(jsonEncode(jsonData)));
      expect(
        note.toJson(),
        equals(jsonData),
        reason: 'Map generated by \'toJson()\' not equal to the one '
            'generated by \'jsonDecode()\'',
      );
    });

    test('from JSON', () {
      var actual = Note.fromJson(jsonData);
      expect(actual.toJson(), equals(note.toJson()));
    });
  });

  group('NotesListModel Class Test', () {
    List<Note> testNotes;
    NotesListModel notesListModel;

    setUp(() {
      testNotes = List<Note>.generate(10, (i) => Note(title: 'Title of note $i', content: 'Content of note $i'));
    });

    test('sets a list of notes', () {
      notesListModel = NotesListModel();

      expect(notesListModel.notes.isEmpty, true);
      notesListModel.notes = testNotes;
      expect(notesListModel.notes.isEmpty, false);
    });

    test('notes load asynchronously', () async {
      notesListModel = NotesListModel();

      var shouldBeEmpty = true;
      notesListModel.addListener(() {
        // print('isEmpty: ${notesListModel.notes.isEmpty}\tshouldBeEmpty: $shouldBeEmpty');
        expect(notesListModel.notes.isEmpty, shouldBeEmpty);
        expect(notesListModel.isLoading, shouldBeEmpty);
        shouldBeEmpty = !shouldBeEmpty;
      });

      expect(notesListModel.notes.isEmpty, true);
      expect(notesListModel.isLoading, false);
      await notesListModel.load(() {
        return Future.delayed(Duration(seconds: 1), () async => testNotes);
      });
      expect(notesListModel.notes.isEmpty, false);
      expect(notesListModel.isLoading, false);
    });

    test('adds a note', () {
      notesListModel = NotesListModel(notes: testNotes);

      final listLength = notesListModel.notes.length;
      final note = Note(title: 'test');

      notesListModel.addNote(note);

      expect(notesListModel.notes.length, greaterThan(listLength));
      expect(notesListModel.notes.contains(note), true);
    });

    test('removes the note', () {
      notesListModel = NotesListModel(notes: testNotes);
      final index = 2;

      final listLength = notesListModel.notes.length;
      final note = notesListModel.notes[index];

      notesListModel.removeNote(note);

      expect(notesListModel.notes.length, lessThan(listLength));
      expect(notesListModel.notes.contains(note), false);
    });

    test('updates the correct note', () {
      notesListModel = NotesListModel(notes: testNotes);
      final index = 2;

      final note = notesListModel.notes[index];
      note.title = 'Test';
      note.content = 'Test';
      notesListModel.updateNote(note);

      expect(notesListModel.notes[index], equals(note));
    });

    test('returns the correct note given its Id', () {
      notesListModel = NotesListModel(notes: testNotes);
      final index = 2;

      final noteId = notesListModel.notes[index].id;
      final note = notesListModel.noteById(noteId);

      expect(notesListModel.notes[index], equals(note));
    });
  });
}
